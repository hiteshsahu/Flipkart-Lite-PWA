'use strict';

var merge = require('webpack-merge');
var createFileTypesMapping = require('./createFileTypesMapping');
var defaultFileTypes = require('./defaultFileTypes');

exports.createConfig = createConfig;
exports.group = group;
exports.env = env;

var isFunction = function isFunction(value) {
  return typeof value === 'function';
};

/**
 * Takes an array of webpack blocks and creates a webpack config out of them.
 * Each webpack block is a callback function which will be invoked to return a
 * partial webpack config. These partial configs are merged to create the
 * final, complete webpack config that will be returned.
 *
 * @param {object}     initialContext                 The blueprint for the initial context object.
 * @param {object}     initialContext.webpack         Webpack instance
 * @param {object}     initialContext.webpackVersion  Webpack version (`{ major, minor, ... }`)
 * @param {Function[]} configSetters  Array of functions as returned by webpack blocks.
 * @return {object}                   Webpack config object.
 */
function createConfig(initialContext, configSetters) {
  if (!initialContext) {
    throw new Error('No initial context passed.');
  }
  if (!Array.isArray(configSetters) || !configSetters.every(isFunction)) {
    throw new Error('Expected parameter \'configSetters\' to be an array of functions.');
  }

  var fileType = createFileTypesMapping(defaultFileTypes);
  var context = Object.assign({ fileType: fileType }, initialContext);

  invokePreHooks(configSetters, context);
  var config = invokeConfigSetters(configSetters, context);
  var postProcessedConfig = invokePostHooks(configSetters, context, config);

  return postProcessedConfig;
}

/**
 * Applies an array of webpack blocks only if `process.env.NODE_ENV` matches the
 * given `envName`. If no `NODE_ENV` is set, it will be treated as 'development'.
 *
 * @param {string} envName            Environment name like 'development', 'production' or 'testing'.
 * @param {Function[]} configSetters  Array of functions as returned by webpack blocks.
 * @return {Function}
 */
function env(envName, configSetters) {
  var currentEnv = process.env.NODE_ENV || 'development';

  if (currentEnv !== envName) {
    return function () {
      return {};
    };
  } else {
    return group(configSetters);
  }
}

/**
 * Combines an array of blocks to a new joined block. Running this single block
 * has the same effect as running all source blocks.
 *
 * @param {Function[]} configSetters  Array of functions as returned by webpack blocks.
 * @return {Function}
 */
function group(configSetters) {
  var pre = getHooks(configSetters, 'pre');
  var post = getHooks(configSetters, 'post');

  var groupBlock = function groupBlock(context, config) {
    // `baseConfig` must be {}, so `invokeConfigSetters()` returns a config
    // diff, not the whole merged config
    var baseConfig = {};
    // `getCompleteConfig` will make sure the whole config is passed as 2nd param when
    // the config setters are invoked, even though the baseConfig is `{}`, not `config`
    var getCompleteConfig = function getCompleteConfig(incompleteConfig) {
      return merge.smart(config, incompleteConfig);
    };
    return invokeConfigSetters(configSetters, context, baseConfig, getCompleteConfig);
  };

  return Object.assign(groupBlock, { pre: pre, post: post });
}

function getHooks(configSetters, type) {
  // Get all the blocks' pre/post hooks
  var hooks = configSetters.filter(function (setter) {
    return Boolean(setter[type]);
  }).map(function (setter) {
    return setter[type];
  });

  // Flatten the array (since each item might be an array as well)
  var flattenedHooks = hooks.map(function (hook) {
    return Array.isArray(hook) ? hook : [hook];
  }).reduce(function (allHooks, someHooks) {
    return allHooks.concat(someHooks);
  }, []);

  return filterDuplicates(flattenedHooks);
}

function invokeConfigSetters(configSetters, context) {
  var baseConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var getCompleteConfig = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : function (config) {
    return config;
  };

  return configSetters.reduce(function (mergedConfig, setter) {
    var configPartial = setter(context, getCompleteConfig(mergedConfig));
    return merge.smart(mergedConfig, configPartial);
  }, baseConfig);
}

function invokePreHooks(configSetters, context) {
  var preHooks = getHooks(configSetters, 'pre');
  preHooks.forEach(function (hook) {
    return hook(context);
  });
}

function invokePostHooks(configSetters, context, config) {
  var postHooks = getHooks(configSetters, 'post');
  return invokeConfigSetters(postHooks, context, config);
}

function filterDuplicates(array) {
  return array.filter(function (item, index) {
    return array.indexOf(item) === index;
  });
}
//# sourceMappingURL=index.js.map