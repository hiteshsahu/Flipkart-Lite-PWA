'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sourceMaps = exports.setOutput = exports.setDevTool = exports.setContext = exports.resolveAliases = exports.performance = exports.entryPoint = exports.customConfig = exports.addPlugins = undefined;

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.addPlugins = addPlugins;
exports.customConfig = customConfig;
exports.entryPoint = entryPoint;
exports.performance = performance;
exports.resolveAliases = resolveAliases;
exports.setContext = setContext;
exports.setDevTool = setDevTool;
exports.setOutput = setOutput;
exports.sourceMaps = sourceMaps;

/**
 * @see https://webpack.github.io/docs/configuration.html#plugins
 */
/*
 * Functions for use in @webpack-blocks/webpack and @webpack-blocks/webpack2.
 */

function addPlugins(plugins) {
  return plugins.length > 0 ? () => ({ plugins: plugins }) : () => ({}); // since webpack-merge would otherwise clear the plugins array
}

function customConfig(wpConfig) {
  return () => wpConfig;
}

/**
 * Adds one or multiple entry points. If the parameter is not an object the
 * entry point(s) will be added to the default chunk named `main`.
 *
 * @param {object|string[]|string} entry
 * @see https://webpack.github.io/docs/configuration.html#entry
 */
function entryPoint(entry) {
  return () => ({
    entry: normalizeEntry(entry)
  });
}

function normalizeEntry(entry) {
  if (Array.isArray(entry)) {
    return {
      main: entry
    };
  } else if (typeof entry === 'string') {
    return {
      main: [entry]
    };
  } else if (typeof entry === 'object') {
    Object.keys(entry).forEach(entryName => {
      if (!Array.isArray(entry[entryName])) {
        entry[entryName] = [entry[entryName]];
      }
    });
    return entry;
  } else {
    throw new Error(`Expected entry point to be object, array or string. Instead got: ${ entry }`);
  }
}

/**
 * @param {object} performanceBudget
 * @param {number} performanceBudget.maxAssetSize
 * @param {number} performanceBudget.maxEntrypointSize
 * @param {string} performanceBudget.hints              'warning' or 'error'
 */
function performance(performanceBudget) {
  return () => ({
    performance: performanceBudget
  });
}

/**
 * @see https://webpack.github.io/docs/configuration.html#resolve-alias
 */
function resolveAliases(aliases) {
  return () => ({
    resolve: {
      alias: aliases
    }
  });
}

/**
 * @see https://webpack.github.io/docs/configuration.html#context
 */
function setContext(contextPath) {
  return () => ({
    context: _path2.default.resolve(contextPath)
  });
}

/**
 * @see https://webpack.github.io/docs/configuration.html#devtool
 */
function setDevTool(devtool) {
  return () => ({ devtool: devtool });
}

/**
 * @see https://webpack.github.io/docs/configuration.html#output
 */
function setOutput(output) {
  if (typeof output === 'string') {
    output = {
      filename: _path2.default.basename(output) || 'bundle.js',
      path: _path2.default.resolve(_path2.default.dirname(output) || './build')
    };
  }

  return () => ({ output: output });
}

/**
 * Just a convenience wrapper to enable sourcemaps in an easier-to-read fashion
 * than `setDevTool()`.
 * @TODO: Only sets the javascript sourcemaps now. Would be nice to make loaders
 *        enable their specific sourcemaps when `sourceMaps()` is used.
 *
 * @param {string} [devtool]
 * @return {Function}
 */
function sourceMaps() {
  let devtool = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'cheap-module-source-map';

  return context => {
    context.sourceMaps = true;
    return { devtool: devtool };
  };
}
//# sourceMappingURL=webpack.js.map